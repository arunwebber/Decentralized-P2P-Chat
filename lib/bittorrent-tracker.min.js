// Automatic P2P pairing using Nostr relay network
window.Client = class TrackerClient {
  constructor(opts) {
    this.opts = opts;
    this.destroyed = false;
    this._onPeer = null;
    this._onError = null;
    this.connected = false;
    this.peer = null;
    this.relay = null;
    this.paired = false;
    this.partnerPubkey = null;
    this.privateKey = null;
    this.publicKey = null;
  }

  start() {
    this.connectViaNostr();
  }

  async connectViaNostr() {
    if (!window.NostrTools) {
      console.error('Nostr library not loaded!');
      return;
    }

    console.log('Connecting to Nostr relay network...');

    // Generate ephemeral keys for this session
    this.privateKey = window.NostrTools.generatePrivateKey();
    this.publicKey = window.NostrTools.getPublicKey(this.privateKey);

    // Public Nostr relays
    const relays = [
      'wss://relay.damus.io',
      'wss://relay.nostr.info',
      'wss://nostr-pub.wellorder.net',
      'wss://relay.current.fyi',
      'wss://nos.lol'
    ];

    // Try to connect to relays
    for (const relayUrl of relays) {
      try {
        await this.connectToRelay(relayUrl);
        if (this.relay) break;
      } catch (e) {
        console.log(`Failed to connect to ${relayUrl}, trying next...`);
      }
    }

    if (!this.relay) {
      console.error('Could not connect to any Nostr relay');
      return;
    }

    // Subscribe to pool events
    this.subscribeToPool();
    
    // Announce ourselves
    this.announceToPool();
  }

  async connectToRelay(url) {
    return new Promise((resolve, reject) => {
      this.relay = window.NostrTools.relayInit(url);
      
      this.relay.on('connect', () => {
        console.log('Connected to Nostr relay:', url);
        resolve();
      });

      this.relay.on('error', () => {
        reject(new Error('Relay connection failed'));
      });

      this.relay.connect();

      // Timeout after 5 seconds
      setTimeout(() => {
        if (this.relay.status !== 1) {
          reject(new Error('Connection timeout'));
        }
      }, 5000);
    });
  }

  subscribeToPool() {
    // Subscribe to stranger chat pool events
    const filters = [{
      kinds: [20000], // Custom kind for stranger chat
      '#t': ['strangerchat-pool'],
      since: Math.floor(Date.now() / 1000) - 60 // Last 60 seconds
    }];

    const sub = this.relay.sub(filters);

    sub.on('event', (event) => {
      // Ignore our own events
      if (event.pubkey === this.publicKey) return;
      
      // Handle pool events
      if (event.content) {
        try {
          const data = JSON.parse(event.content);
          this.handlePoolEvent(data, event.pubkey);
        } catch (e) {
          console.error('Invalid event data:', e);
        }
      }
    });
  }

  announceToPool() {
    console.log('Announcing to pool...');

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [['t', 'strangerchat-pool']],
      content: JSON.stringify({
        type: 'looking',
        timestamp: Date.now()
      })
    };

    // Sign the event
    event.id = window.NostrTools.getEventHash(event);
    event.sig = window.NostrTools.signEvent(event, this.privateKey);

    // Publish
    this.relay.publish(event);

    // Re-announce every 10 seconds if not paired
    this.announceInterval = setInterval(() => {
      if (!this.paired && !this.connected) {
        this.relay.publish(event);
      } else {
        clearInterval(this.announceInterval);
      }
    }, 10000);
  }

  handlePoolEvent(data, senderPubkey) {
    if (this.paired || this.destroyed) return;

    if (data.type === 'looking') {
      console.log('Found someone looking for a match!');
      
      // Deterministic pairing - smaller pubkey initiates
      if (!this.paired && this.publicKey < senderPubkey) {
        this.initiatePairing(senderPubkey);
      }
    } else if (data.type === 'pair-request' && data.target === this.publicKey) {
      console.log('Received pairing request!');
      if (!this.paired) {
        this.acceptPairing(senderPubkey);
      }
    } else if (data.type === 'pair-accept' && data.target === this.publicKey) {
      console.log('Pairing accepted!');
      this.completePairing(senderPubkey, true);
    } else if (data.type === 'webrtc-signal' && senderPubkey === this.partnerPubkey) {
      console.log('Received WebRTC signal');
      if (this.peer && data.signal) {
        this.peer.signal(data.signal);
      }
    }
  }

  initiatePairing(targetPubkey) {
    console.log('Initiating pairing...');
    this.paired = true;
    this.partnerPubkey = targetPubkey;

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [['t', 'strangerchat-pool'], ['p', targetPubkey]],
      content: JSON.stringify({
        type: 'pair-request',
        target: targetPubkey
      })
    };

    event.id = window.NostrTools.getEventHash(event);
    event.sig = window.NostrTools.signEvent(event, this.privateKey);

    this.relay.publish(event);
  }

  acceptPairing(requesterPubkey) {
    console.log('Accepting pairing...');
    this.paired = true;
    this.partnerPubkey = requesterPubkey;

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [['t', 'strangerchat-pool'], ['p', requesterPubkey]],
      content: JSON.stringify({
        type: 'pair-accept',
        target: requesterPubkey
      })
    };

    event.id = window.NostrTools.getEventHash(event);
    event.sig = window.NostrTools.signEvent(event, this.privateKey);

    this.relay.publish(event);
    
    this.completePairing(requesterPubkey, false);
  }

  completePairing(partnerPubkey, isInitiator) {
    console.log('Creating P2P connection...');

    this.peer = new SimplePeer({
      initiator: isInitiator,
      trickle: false,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:global.stun.twilio.com:3478' },
          {
            urls: 'turn:openrelay.metered.ca:80',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          },
          {
            urls: 'turn:openrelay.metered.ca:443',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ]
      }
    });

    this.peer.on('signal', (signal) => {
      console.log('Sending WebRTC signal via Nostr...');
      
      const event = {
        kind: 20000,
        pubkey: this.publicKey,
        created_at: Math.floor(Date.now() / 1000),
        tags: [['t', 'strangerchat-pool'], ['p', partnerPubkey]],
        content: JSON.stringify({
          type: 'webrtc-signal',
          signal: signal
        })
      };

      event.id = window.NostrTools.getEventHash(event);
      event.sig = window.NostrTools.signEvent(event, this.privateKey);

      this.relay.publish(event);
    });

    this.peer.on('connect', () => {
      console.log('P2P CONNECTED! Direct connection established.');
      this.connected = true;
      
      // Close Nostr connection - no longer needed
      if (this.relay) {
        this.relay.close();
        this.relay = null;
      }
      
      console.log('Nostr relay disconnected. Pure P2P active!');
    });

    this.peer.on('error', (err) => {
      console.error('P2P error:', err);
    });

    this.peer.on('close', () => {
      this.connected = false;
      this.paired = false;
      this.partnerPubkey = null;
      
      // Restart pairing
      if (!this.destroyed) {
        setTimeout(() => this.start(), 2000);
      }
    });

    if (this._onPeer) {
      this._onPeer(this.peer);
    }
  }

  on(event, callback) {
    if (event === 'peer') {
      this._onPeer = callback;
    } else if (event === 'error') {
      this._onError = callback;
    } else if (event === 'warning') {
      // Ignore
    }
  }

  destroy() {
    this.destroyed = true;
    this.connected = false;
    this.paired = false;
    
    clearInterval(this.announceInterval);
    
    if (this.relay) {
      this.relay.close();
    }
    
    if (this.peer) {
      this.peer.destroy();
    }
  }
  
  signal(data) {
    if (this.peer && this.peer.signal) {
      this.peer.signal(data);
    }
  }
}

// Make it compatible
window.bittorrentTrackerClient = window.Client;
window.BittorrentTrackerClient = window.Client;
window.bittorrentTracker = { Client: window.Client };