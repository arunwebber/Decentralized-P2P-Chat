// Automatic P2P pairing using Nostr relay network
window.Client = class TrackerClient {
  constructor(opts) {
    this.opts = opts;
    this.destroyed = false;
    this._onPeer = null;
    this._onError = null;
    this.connected = false;
    this.peer = null;
    this.relay = null;
    this.paired = false;
    this.partnerPubkey = null;
    this.privateKey = null;
    this.publicKey = null;
    this.sub = null;
  }

  start() {
    this.connectViaNostr();
  }

  async connectViaNostr() {
    if (!window.NostrTools) {
      console.error('Nostr library not loaded!');
      return;
    }

    console.log('Connecting to Nostr relay network...');

    // Generate ephemeral keys for this session
    this.privateKey = window.NostrTools.generatePrivateKey();
    this.publicKey = window.NostrTools.getPublicKey(this.privateKey);
    
    console.log('My public key:', this.publicKey.substring(0, 8) + '...');

    // Public Nostr relays
    const relays = [
      'wss://relay.damus.io',
      'wss://nos.lol',
      'wss://relay.nostr.band',
      'wss://relayable.org'
    ];

    // Try to connect to relays
    for (const relayUrl of relays) {
      try {
        await this.connectToRelay(relayUrl);
        if (this.relay) break;
      } catch (e) {
        console.log(`Failed to connect to ${relayUrl}, trying next...`);
      }
    }

    if (!this.relay) {
      console.error('Could not connect to any Nostr relay');
      return;
    }

    // Subscribe to pool events
    this.subscribeToPool();
    
    // Small delay before announcing
    setTimeout(() => this.announceToPool(), 1000);
  }

  async connectToRelay(url) {
    return new Promise((resolve, reject) => {
      this.relay = window.NostrTools.relayInit(url);
      
      this.relay.on('connect', () => {
        console.log('Connected to Nostr relay:', url);
        resolve();
      });

      this.relay.on('error', () => {
        reject(new Error('Relay connection failed'));
      });

      this.relay.connect();

      // Timeout after 5 seconds
      setTimeout(() => {
        if (this.relay.status !== 1) {
          reject(new Error('Connection timeout'));
        }
      }, 5000);
    });
  }

  subscribeToPool() {
    // Subscribe to ALL stranger chat events
    const filters = [
      {
        kinds: [20000], // Custom kind for stranger chat
        since: Math.floor(Date.now() / 1000) - 120 // Last 2 minutes
      }
    ];

    this.sub = this.relay.sub(filters);

    this.sub.on('event', (event) => {
      // Ignore our own events
      if (event.pubkey === this.publicKey) return;
      
      // Handle pool events
      if (event.content) {
        try {
          const data = JSON.parse(event.content);
          // Check if this message is for stranger chat
          if (data.app === 'strangerchat') {
            console.log('Received event from:', event.pubkey.substring(0, 8) + '...', data.type);
            this.handlePoolEvent(data, event.pubkey);
          }
        } catch (e) {
          console.error('Invalid event data:', e);
        }
      }
    });
  }

  // Fixed signature method
  signEvent(event) {
    event.id = window.NostrTools.getEventHash(event);
    
    // Use the correct method based on what's available
    if (window.NostrTools.getSignature) {
      event.sig = window.NostrTools.getSignature(event, this.privateKey);
    } else if (window.NostrTools.signEvent) {
      event.sig = window.NostrTools.signEvent(event, this.privateKey);
    } else {
      console.error('No signature method available');
    }
    
    return event;
  }

  announceToPool() {
    if (this.paired || this.destroyed) return;
    
    console.log('Announcing to pool...');

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [],
      content: JSON.stringify({
        app: 'strangerchat',
        type: 'looking',
        pubkey: this.publicKey,
        timestamp: Date.now()
      })
    };

    this.signEvent(event);
    this.relay.publish(event);
    console.log('Announce published');

    // Re-announce every 15 seconds if not paired
    if (this.announceInterval) clearInterval(this.announceInterval);
    this.announceInterval = setInterval(() => {
      if (!this.paired && !this.destroyed) {
        this.announceToPool();
      }
    }, 15000);
  }

  handlePoolEvent(data, senderPubkey) {
    if (this.destroyed) return;

    if (data.type === 'looking' && !this.paired) {
      console.log('Found someone looking for a match!');
      
      // Deterministic pairing - smaller pubkey initiates
      if (this.publicKey < senderPubkey) {
        console.log('I will initiate (smaller pubkey)');
        this.initiatePairing(senderPubkey);
      }
    } else if (data.type === 'pair-request' && data.target === this.publicKey && !this.paired) {
      console.log('Received pairing request!');
      this.acceptPairing(senderPubkey);
    } else if (data.type === 'pair-accept' && data.target === this.publicKey && data.from === this.partnerPubkey) {
      console.log('Pairing accepted!');
      // Delay to ensure other side is ready
      setTimeout(() => this.startP2P(true), 500);
    } else if (data.type === 'webrtc-signal' && data.target === this.publicKey && data.from === this.partnerPubkey) {
      console.log('Received WebRTC signal');
      if (this.peer && data.signal) {
        try {
          this.peer.signal(data.signal);
        } catch (e) {
          console.error('Error applying signal:', e);
        }
      } else {
        console.error('Peer not ready for signal');
      }
    }
  }

  initiatePairing(targetPubkey) {
    if (this.paired) return;
    
    console.log('Initiating pairing...');
    this.paired = true;
    this.partnerPubkey = targetPubkey;

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [],
      content: JSON.stringify({
        app: 'strangerchat',
        type: 'pair-request',
        target: targetPubkey,
        from: this.publicKey
      })
    };

    this.signEvent(event);
    this.relay.publish(event);
    console.log('Pairing request sent to', targetPubkey.substring(0, 8) + '...');
  }

  acceptPairing(requesterPubkey) {
    if (this.paired) return;
    
    console.log('Accepting pairing...');
    this.paired = true;
    this.partnerPubkey = requesterPubkey;

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [],
      content: JSON.stringify({
        app: 'strangerchat',
        type: 'pair-accept',
        target: requesterPubkey,
        from: this.publicKey
      })
    };

    this.signEvent(event);
    this.relay.publish(event);
    console.log('Pairing acceptance sent');
    
    // Start P2P as responder
    setTimeout(() => this.startP2P(false), 500);
  }

  startP2P(isInitiator) {
    console.log('Creating P2P connection...', isInitiator ? 'as initiator' : 'as responder');

    // Check if SimplePeer is available
    if (!window.SimplePeer) {
      console.error('SimplePeer not loaded!');
      this.paired = false;
      return;
    }

    this.peer = new SimplePeer({
      initiator: isInitiator,
      trickle: false,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:global.stun.twilio.com:3478' },
          {
            urls: 'turn:openrelay.metered.ca:80',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ]
      }
    });

    // Add send method for compatibility
    if (!this.peer.send) {
      this.peer.send = (data) => {
        if (this.peer.connected) {
          this.peer.write(data);
        }
      };
    }

    this.peer.on('signal', (signal) => {
      console.log('Generated WebRTC signal, sending via Nostr...');
      
      const event = {
        kind: 20000,
        pubkey: this.publicKey,
        created_at: Math.floor(Date.now() / 1000),
        tags: [],
        content: JSON.stringify({
          app: 'strangerchat',
          type: 'webrtc-signal',
          target: this.partnerPubkey,
          from: this.publicKey,
          signal: signal
        })
      };

      this.signEvent(event);
      this.relay.publish(event);
      console.log('Signal sent to', this.partnerPubkey.substring(0, 8) + '...');
    });

    this.peer.on('connect', () => {
      console.log('P2P CONNECTED! Direct connection established.');
      this.connected = true;
      
      // Clear announce interval
      if (this.announceInterval) {
        clearInterval(this.announceInterval);
      }
      
      // Close Nostr connection after a delay
      setTimeout(() => {
        if (this.relay) {
          console.log('Closing Nostr relay - pure P2P active!');
          this.relay.close();
          this.relay = null;
        }
      }, 2000);
    });

    this.peer.on('data', (data) => {
      console.log('Received P2P data:', data);
    });

    this.peer.on('error', (err) => {
      console.error('P2P error:', err);
      if (this._onError) this._onError(err);
    });

    this.peer.on('close', () => {
      console.log('P2P disconnected');
      this.connected = false;
      this.paired = false;
      this.partnerPubkey = null;
      
      // Restart pairing
      if (!this.destroyed) {
        setTimeout(() => this.start(), 2000);
      }
    });

    // Emit peer event
    if (this._onPeer) {
      this._onPeer(this.peer);
    }
  }

  on(event, callback) {
    if (event === 'peer') {
      this._onPeer = callback;
    } else if (event === 'error') {
      this._onError = callback;
    } else if (event === 'warning') {
      // Ignore warnings for now
    }
  }

  destroy() {
    this.destroyed = true;
    this.connected = false;
    this.paired = false;
    
    if (this.announceInterval) {
      clearInterval(this.announceInterval);
      this.announceInterval = null;
    }
    
    if (this.sub) {
      this.sub.unsub();
    }
    
    if (this.relay) {
      this.relay.close();
      this.relay = null;
    }
    
    if (this.peer) {
      this.peer.destroy();
      this.peer = null;
    }
    
    this.partnerPubkey = null;
    this.privateKey = null;
    this.publicKey = null;
  }
  
  // For manual signaling compatibility
  signal(data) {
    if (this.peer && this.peer.signal) {
      this.peer.signal(data);
    }
  }
}

// Make it compatible with multiple naming conventions
window.bittorrentTrackerClient = window.Client;
window.BittorrentTrackerClient = window.Client;
window.bittorrentTracker = { Client: window.Client };