// Automatic P2P pairing using Nostr relay network with rate limiting fixes
window.Client = class TrackerClient {
  constructor(opts) {
    this.opts = opts;
    this.destroyed = false;
    this._onPeer = null;
    this._onError = null;
    this.connected = false;
    this.peer = null;
    this.relay = null;
    this.paired = false;
    this.partnerPubkey = null;
    this.privateKey = null;
    this.publicKey = null;
    this.sub = null;
    
    // Rate limiting features
    this.messageQueue = [];
    this.sendingMessage = false;
    this.lastMessageTime = 0;
    this.minMessageDelay = 500; // 500ms between messages
  }

  start() {
    this.connectViaNostr();
  }

  async connectViaNostr() {
    if (!window.NostrTools) {
      console.error('Nostr library not loaded!');
      return;
    }

    console.log('Connecting to Nostr relay network...');

    // Generate ephemeral keys for this session
    this.privateKey = window.NostrTools.generatePrivateKey();
    this.publicKey = window.NostrTools.getPublicKey(this.privateKey);
    
    console.log('My public key:', this.publicKey.substring(0, 8) + '...');

    // Public Nostr relays
    const relays = [
      'wss://relay.damus.io',
      'wss://nos.lol',
      'wss://relay.nostr.band',
      'wss://relayable.org',
      'wss://relay.snort.social',
      'wss://nostr-pub.wellorder.net'
    ];

    this.connectedRelays = [];
    this.currentRelayIndex = 0;

    // Try to connect to multiple relays
    for (const relayUrl of relays) {
      try {
        const relay = await this.connectToRelay(relayUrl);
        if (relay) {
          this.connectedRelays.push({ url: relayUrl, relay: relay });
          if (this.connectedRelays.length >= 2) break; // Connect to max 2 relays
        }
      } catch (e) {
        console.log(`Failed to connect to ${relayUrl}, trying next...`);
      }
    }

    if (this.connectedRelays.length === 0) {
      console.error('Could not connect to any Nostr relay');
      return;
    }

    // Use first relay as primary
    this.relay = this.connectedRelays[0].relay;
    console.log(`Connected to ${this.connectedRelays.length} relay(s)`);

    // Subscribe to pool events on all connected relays
    this.connectedRelays.forEach(({ relay }) => {
      this.subscribeToPool(relay);
    });
    
    // Small delay before announcing
    setTimeout(() => this.announceToPool(), 2000);
  }

  async connectToRelay(url) {
    return new Promise((resolve, reject) => {
      const relay = window.NostrTools.relayInit(url);
      
      relay.on('connect', () => {
        console.log('Connected to Nostr relay:', url);
        resolve(relay);
      });

      relay.on('error', () => {
        reject(new Error('Relay connection failed'));
      });

      relay.connect();

      // Timeout after 5 seconds
      setTimeout(() => {
        if (relay.status !== 1) {
          reject(new Error('Connection timeout'));
        }
      }, 5000);
    });
  }

  subscribeToPool(relay) {
    // Subscribe to ALL stranger chat events
    const filters = [
      {
        kinds: [20000], // Custom kind for stranger chat
        since: Math.floor(Date.now() / 1000) - 300 // Last 5 minutes
      }
    ];

    const sub = relay.sub(filters);

    sub.on('event', (event) => {
      // Ignore our own events
      if (event.pubkey === this.publicKey) return;
      
      // Handle pool events
      if (event.content) {
        try {
          const data = JSON.parse(event.content);
          // Check if this message is for stranger chat
          if (data.app === 'strangerchat') {
            console.log('Received event from:', event.pubkey.substring(0, 8) + '...', data.type);
            this.handlePoolEvent(data, event.pubkey);
          }
        } catch (e) {
          console.error('Invalid event data:', e);
        }
      }
    });
  }

  // Fixed signature method
  signEvent(event) {
    event.id = window.NostrTools.getEventHash(event);
    
    // Use the correct method based on what's available
    if (window.NostrTools.getSignature) {
      event.sig = window.NostrTools.getSignature(event, this.privateKey);
    } else if (window.NostrTools.signEvent) {
      event.sig = window.NostrTools.signEvent(event, this.privateKey);
    } else {
      console.error('No signature method available');
    }
    
    return event;
  }

  // Queue system for rate limiting
  async queuedPublish(event) {
    return new Promise((resolve) => {
      this.messageQueue.push({ event, resolve });
      if (!this.sendingMessage) {
        this.processSendQueue();
      }
    });
  }

  async processSendQueue() {
    if (this.messageQueue.length === 0 || this.sendingMessage || this.destroyed) return;
    
    this.sendingMessage = true;
    const { event, resolve } = this.messageQueue.shift();
    
    try {
      // Ensure minimum delay between messages
      const now = Date.now();
      const timeSinceLastMessage = now - this.lastMessageTime;
      if (timeSinceLastMessage < this.minMessageDelay) {
        await new Promise(r => setTimeout(r, this.minMessageDelay - timeSinceLastMessage));
      }
      
      // Use round-robin relay selection if multiple relays
      if (this.connectedRelays.length > 1) {
        this.currentRelayIndex = (this.currentRelayIndex + 1) % this.connectedRelays.length;
        const relay = this.connectedRelays[this.currentRelayIndex].relay;
        relay.publish(event);
      } else {
        this.relay.publish(event);
      }
      
      this.lastMessageTime = Date.now();
      console.log('Message sent successfully');
      resolve();
      
    } catch (e) {
      console.error('Failed to send message:', e);
      resolve(); // Resolve anyway to continue processing
    }
    
    this.sendingMessage = false;
    
    // Process next message if any
    if (this.messageQueue.length > 0) {
      setTimeout(() => this.processSendQueue(), 100);
    }
  }

  async announceToPool() {
    if (this.paired || this.destroyed) return;
    
    console.log('Announcing to pool...');

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [],
      content: JSON.stringify({
        app: 'strangerchat',
        type: 'looking',
        pubkey: this.publicKey,
        timestamp: Date.now()
      })
    };

    this.signEvent(event);
    await this.queuedPublish(event);
    console.log('Announce published');

    // Re-announce every 30 seconds if not paired (increased from 15)
    if (this.announceInterval) clearInterval(this.announceInterval);
    this.announceInterval = setInterval(() => {
      if (!this.paired && !this.destroyed) {
        this.announceToPool();
      }
    }, 30000); // 30 seconds
  }

  handlePoolEvent(data, senderPubkey) {
    if (this.destroyed) return;

    if (data.type === 'looking' && !this.paired) {
      console.log('Found someone looking for a match!');
      
      // Deterministic pairing - smaller pubkey initiates
      if (this.publicKey < senderPubkey) {
        console.log('I will initiate (smaller pubkey)');
        // Add delay to avoid race conditions
        setTimeout(() => this.initiatePairing(senderPubkey), Math.random() * 1000 + 500);
      }
    } else if (data.type === 'pair-request' && data.target === this.publicKey && !this.paired) {
      console.log('Received pairing request!');
      this.acceptPairing(senderPubkey);
    } else if (data.type === 'pair-accept' && data.target === this.publicKey && data.from === this.partnerPubkey) {
      console.log('Pairing accepted!');
      // Delay to ensure other side is ready
      setTimeout(() => this.startP2P(true), 1000);
    } else if (data.type === 'webrtc-signal' && data.target === this.publicKey && data.from === this.partnerPubkey) {
      console.log('Received WebRTC signal');
      if (this.peer && data.signal) {
        try {
          this.peer.signal(data.signal);
        } catch (e) {
          console.error('Error applying signal:', e);
        }
      } else {
        console.error('Peer not ready for signal');
      }
    }
  }

  async initiatePairing(targetPubkey) {
    if (this.paired) return;
    
    console.log('Initiating pairing...');
    this.paired = true;
    this.partnerPubkey = targetPubkey;

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [],
      content: JSON.stringify({
        app: 'strangerchat',
        type: 'pair-request',
        target: targetPubkey,
        from: this.publicKey
      })
    };

    this.signEvent(event);
    await this.queuedPublish(event);
    console.log('Pairing request sent to', targetPubkey.substring(0, 8) + '...');
  }

  async acceptPairing(requesterPubkey) {
    if (this.paired) return;
    
    console.log('Accepting pairing...');
    this.paired = true;
    this.partnerPubkey = requesterPubkey;

    const event = {
      kind: 20000,
      pubkey: this.publicKey,
      created_at: Math.floor(Date.now() / 1000),
      tags: [],
      content: JSON.stringify({
        app: 'strangerchat',
        type: 'pair-accept',
        target: requesterPubkey,
        from: this.publicKey
      })
    };

    this.signEvent(event);
    await this.queuedPublish(event);
    console.log('Pairing acceptance sent');
    
    // Start P2P as responder
    setTimeout(() => this.startP2P(false), 1000);
  }

  startP2P(isInitiator) {
    console.log('Creating P2P connection...', isInitiator ? 'as initiator' : 'as responder');

    // Check if SimplePeer is available
    if (!window.SimplePeer) {
      console.error('SimplePeer not loaded!');
      this.paired = false;
      return;
    }

    this.peer = new SimplePeer({
      initiator: isInitiator,
      trickle: false,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:global.stun.twilio.com:3478' },
          {
            urls: 'turn:openrelay.metered.ca:80',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ]
      }
    });

    // Add send method for compatibility
    if (!this.peer.send) {
      this.peer.send = (data) => {
        if (this.peer.connected) {
          this.peer.write(data);
        }
      };
    }

    this.peer.on('signal', async (signal) => {
      console.log('Generated WebRTC signal, sending via Nostr...');
      
      const event = {
        kind: 20000,
        pubkey: this.publicKey,
        created_at: Math.floor(Date.now() / 1000),
        tags: [],
        content: JSON.stringify({
          app: 'strangerchat',
          type: 'webrtc-signal',
          target: this.partnerPubkey,
          from: this.publicKey,
          signal: signal
        })
      };

      this.signEvent(event);
      await this.queuedPublish(event);
      console.log('Signal sent to', this.partnerPubkey.substring(0, 8) + '...');
    });

    this.peer.on('connect', () => {
      console.log('P2P CONNECTED! Direct connection established.');
      this.connected = true;
      
      // Clear announce interval
      if (this.announceInterval) {
        clearInterval(this.announceInterval);
        this.announceInterval = null;
      }
      
      // Close Nostr connections after a delay
      setTimeout(() => {
        if (this.connectedRelays && this.connectedRelays.length > 0) {
          console.log('Closing Nostr relays - pure P2P active!');
          this.connectedRelays.forEach(({ relay }) => {
            try {
              relay.close();
            } catch (e) {
              console.error('Error closing relay:', e);
            }
          });
          this.connectedRelays = [];
          this.relay = null;
        }
      }, 2000);
    });

    this.peer.on('data', (data) => {
      console.log('Received P2P data:', data);
    });

    this.peer.on('error', (err) => {
      console.error('P2P error:', err);
      if (this._onError) this._onError(err);
    });

    this.peer.on('close', () => {
      console.log('P2P disconnected');
      this.connected = false;
      this.paired = false;
      this.partnerPubkey = null;
      
      // Clear message queue
      this.messageQueue = [];
      
      // Restart pairing after a delay
      if (!this.destroyed) {
        setTimeout(() => this.start(), 3000);
      }
    });

    // Emit peer event
    if (this._onPeer) {
      this._onPeer(this.peer);
    }
  }

  on(event, callback) {
    if (event === 'peer') {
      this._onPeer = callback;
    } else if (event === 'error') {
      this._onError = callback;
    } else if (event === 'warning') {
      // Ignore warnings for now
    }
  }

  destroy() {
    this.destroyed = true;
    this.connected = false;
    this.paired = false;
    
    // Clear intervals
    if (this.announceInterval) {
      clearInterval(this.announceInterval);
      this.announceInterval = null;
    }
    
    // Clear message queue
    this.messageQueue = [];
    
    // Close all relay connections
    if (this.connectedRelays && this.connectedRelays.length > 0) {
      this.connectedRelays.forEach(({ relay }) => {
        try {
          if (relay.status === 1) {
            relay.close();
          }
        } catch (e) {
          console.error('Error closing relay:', e);
        }
      });
      this.connectedRelays = [];
    }
    
    // Clean up main relay reference
    if (this.relay) {
      try {
        this.relay.close();
      } catch (e) {
        console.error('Error closing main relay:', e);
      }
      this.relay = null;
    }
    
    // Destroy peer connection
    if (this.peer) {
      try {
        this.peer.destroy();
      } catch (e) {
        console.error('Error destroying peer:', e);
      }
      this.peer = null;
    }
    
    // Clear references
    this.partnerPubkey = null;
    this.privateKey = null;
    this.publicKey = null;
    this._onPeer = null;
    this._onError = null;
  }
  
  // For manual signaling compatibility
  signal(data) {
    if (this.peer && this.peer.signal) {
      this.peer.signal(data);
    }
  }
}

// Make it compatible with multiple naming conventions
window.bittorrentTrackerClient = window.Client;
window.BittorrentTrackerClient = window.Client;
window.bittorrentTracker = { Client: window.Client };